Discriminator===

import sys
import numpy as np

from keras.layers import  Input, Dense, Reshape, Flatten, Dropout
from keras.layers.advanced_activations import LeakyReLU
from keras.models import Sequential, Model
from keras.optimizers import Adam
from keras.utils import plot_model


class Discriminator(object) :
    def __init__(self, width=28, height=28, channels=1, latent_size=100):
        self.CAPACITY = width * height * channels
        self.SHAPE = (width, height, channels)
        self.OPTIMIZER = Adam(lr=0.0002, decay=8e-9)

        # model initialize
        self.Discriminator = self.model()

        # model compile
        self.Discriminator.compile(loss='binary_crossentropy', optimizer=self.OPTIMIZER, metrics=['accuracy'])

        # self.save_model()

        # summary
        self.summary()

    # model define
    def model(self):
        model = Sequential()
        model.add(Flatten(input_shape=self.SHAPE))
        model.add(Dense(self.CAPACITY, input_shape=self.SHAPE))
        model.add(LeakyReLU(alpha=0.2))
        model.add(Dense(int(self.CAPACITY / 2)))
        model.add(LeakyReLU(alpha=0.2))
        model.add(Dense(1, activation='sigmoid'))
        return model

    def summary(self):
        return self.Discriminator.summary()

    def save_model(self):
        plot_model(self.Discriminator.model,
                   to_file='./model/discriminator.png')



Generator===

import sys
import numpy as np

from keras.layers import  Dense, Reshape
from keras.layers import BatchNormalization
from keras.layers.advanced_activations import LeakyReLU
from keras.models import Sequential, Model
from keras.optimizers import Adam
from keras.utils import plot_model

class Generator(object) :
    def __init__(self, width=28, height=28, channels=1, latent_size=100):
        self.W = width
        self.H = height
        self.C = channels
        self.OPTIMIZER = Adam(lr=0.0002, decay=8e-9)

        # latent space는 잠재공간을 의미한다.
        self.LATENT_SPACE_SIZE = latent_size
        self.latent_space = np.random.normal(0,1,(self.LATENT_SPACE_SIZE,))

        self.Generator = self.model()
        self.Generator.compile(loss='binary_crossentropy',
                               optimizer=self.OPTIMIZER)
        # self.save_model()
        self.summary()

    def model (self, block_starting_szie =128, num_blocks=4) :

        block_size = block_starting_szie

        model=Sequential()
        model.add(Dense(block_size, input_shape=(self.LATENT_SPACE_SIZE,)))
        model.add(LeakyReLU(alpha=0.2))
        model.add(BatchNormalization(momentum=0.8))

        for i in range(num_blocks-1) :
            block_size = block_size * 2
            model.add(Dense(block_size))
            model.add(LeakyReLU(alpha=0.2))
            model.add(BatchNormalization(momentum=0.8))

        model.add(Dense(self.W * self.H * self.C, activation='tanh'))
        model.add(Reshape((self.W, self.H, self.C)))
        return model

    def summary(self):
        return self.Generator.summary()

    def save_model(self):
        plot_model(self.Generator.model,
                   to_file='./model/Generator.png')


gan===

import sys
import numpy as np

from keras.layers import  Input, Dense, Reshape, Flatten, Dropout
from keras.layers.advanced_activations import LeakyReLU
from keras.models import Sequential, Model
from keras.optimizers import Adam
from keras.utils import plot_model


class GAN(object) :
    def __init__(self, discriminator, generator):
        self.OPTIMIZER = Adam(lr=0.0002, decay=8e-9)
        self.Generator = generator

        self.Discriminator = discriminator
        self.Discriminator.trainable = False

        self.gan_model = self.model()
        self.gan_model.compile(loss='binary_crossentropy',
                               optimizer=self.OPTIMIZER)
        # self.save_model()
        self.summary()


    def model(self) :
        model = Sequential()
        model.add(self.Generator)
        model.add(self.Discriminator)
        return  model

    def summary(self):
        return self.gan_model.summary()

    def save_model(self):
        plot_model(self.gan_model.model, to_file='./model/GAN.png')
		
		

train===

from gan import GAN
from generator import Generator
from discriminator import Discriminator
from keras.datasets import mnist
from random import randint
import numpy as np
import matplotlib.pyplot as plt

class Trainer:
    def __init__(self, width=28, height=28, channels=1,
                 latent_size=100, epochs=50000, batch=32,
                 checkpoint=50, model_type=-1):

        self.W = width
        self.H = height
        self.C = channels

        self.EPOCHS = epochs
        self.batch_size = batch
        self.chekpoint = checkpoint

        self.model_type = model_type
        self.latent_space_size = latent_size

        self.generator = Generator(height=self.H, width=self.W, channels=self.C,
                                   latent_size=self.latent_space_size)
        self.discriminator = Discriminator(height=self.H, width=self.W, channels=self.C)
        self.gan = GAN(discriminator=self.discriminator.Discriminator, generator=self.generator.Generator)

        self.load_MINIST()


    def load_MINIST(self,model_type=3):

        allowed_types=[-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        if self.model_type not in allowed_types :
            print("ERROR : Only Integer Values from -1 to 9 are allowed")

        (self.X_train, self.Y_train),(_, _) = mnist.load_data()
        if self.model_type != -1:
            self.X_train = self.X_train[np.where(self.Y_train == int(self.model_type))[0]]

        self.X_train = (np.float32(self.X_train) - 127.5) / 127.5
        self.X_train = np.expand_dims(self.X_train, axis=3)

        return


    def train(self):
        for e in range(self.EPOCHS) :
            # batch
            count_real_images = int(self.batch_size/2)
            starting_index = randint(0, (len(self.X_train) - count_real_images))
            real_images_raw = self.X_train[starting_index : (starting_index + count_real_images)]
            x_real_images = real_images_raw.reshape( count_real_images, self.W, self.H, self.C)
            y_real_labels = np.ones([count_real_images, 1])

            # 나머지 batch
            latent_space_samples = self.sample_latent_space(count_real_images)
            x_generated_images = self.generator.Generator.predict(latent_space_samples)
            y_generated_labels = np.zeros([self.batch_size - count_real_images, 1])

            # discriminator를 위해 data concat
            x_batch = np.concatenate([x_real_images, x_generated_images])
            y_batch = np.concatenate([y_real_labels, y_generated_labels])

            # train the discriminator using batch
            discriminator_loss = self.discriminator.Discriminator.train_on_batch(x_batch, y_batch)[0]

            # train the generator
            x_latent_space_samples = self.sample_latent_space(self.batch_size)
            y_generated_labels = np.ones([self.batch_size, 1])
            generator_loss = self.gan.gan_model.train_on_batch(x_latent_space_samples, y_generated_labels)

            print('Epoch : ' + str(int(e)) + ', [Discriminator :: Loss : '
                  + str(discriminator_loss) + '], [Generator :: Loss : ' + str(generator_loss) + ']')

            if e % self.chekpoint == 0 :
                self.plot_checkpoint(e)

        return

    def sample_latent_space(self, instances):
        return np.random.normal(0, 1, (instances, self.latent_space_size))

    def plot_checkpoint(self, e):
        filename = "./model/sample_" + str(e) + ".png"

        # generator가 그린 그림을 보여줌
        noise = self.sample_latent_space(16)
        images = self.generator.Generator.predict(noise)

        plt.figure(figsize=(10, 10))
        for i in range(images.shape[0]) :
            plt.subplot(4, 4, i + 1)
            image = images[i, :, :, :]
            image = np.reshape(image, [self.H, self.W])
            plt.imshow(image, cmap='gray')
            plt.axis('off')
            plt.tight_layout()
            plt.savefig(filename)
            plt.close('all')
            return


run===
from train import Trainer

if __name__ == "__main__":

    HEIGHT = 28
    WIDTH = 28
    CHANNEL = 1
    LATENT_SPACE_SIZE = 100
    EPOCHS = 50001
    BATCH = 32
    CHECKPOINT = 500
    MODEL_TYPE = -1
    trainer = Trainer(height=HEIGHT,
                      width=WIDTH,
                      channels=CHANNEL,
                      latent_size=LATENT_SPACE_SIZE,
                      epochs=EPOCHS,
                      batch=BATCH,
                      checkpoint=CHECKPOINT,
                      model_type=MODEL_TYPE)

    trainer.train()
	

